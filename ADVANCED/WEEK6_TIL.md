# SQL_ADVANCED 6주차 정규 과제

## Week 6 : 정규 표현식 (REGEXP)

📌**SQL_ADVANCED 정규과제**는 매주 정해진 주제에 따라 **MySQL 공식 문서 또는 한글 블로그 자료를 참고해 개념을 정리한 후, 프로그래머스 SQL 문제 3문제**와 **추가 확인문제**를 직접 풀어보며 학습하는 과제입니다.

이번 주는 아래의 **SQL_ADVANCED_6th_TIL**에 나열된 주제를 중심으로 개념을 학습하고, 주차별 **학습 목표**에 맞게 정리해주세요. 정리한 내용은 GitHub에 업로드한 후, **스프레드시트의 ‘SQL’ 시트에 링크를 제출**해주세요.

**(수행 인증샷은 필수입니다.)**

> 프로그래머스 문제를 풀고 ‘정답입니다’ 문구를 캡쳐해서 올려주시면 됩니다.

**(마지막 주차입니다. 조금만 더 힘내주세요~!!!)**
네~~

## **SQL_ADVANCED_6th_TIL**

### 14.8.2 Regular Expressions

- **REGEXP/RLIKE 연산자와 REGEXP_LIKE(), REGEXP_REPLACE() 등 함수 사용법 및 정규표현식 패턴 문법을 학습하세요.**



### 공식 문서 활용 팁

>  **MySQL 공식 문서는 영어로 제공되지만, 크롬 브라우저에서 공식 문서를 열고 이 페이지 번역하기에서 한국어를 선택하면 번역된 버전으로 확인할 수 있습니다. 다만, 번역본은 문맥이 어색한 부분이 종종 있으니 영어 원문과 한국어 번역본을 왔다 갔다 하며 확인하거나, 교육팀장의 정리 예시를 참고하셔도 괜찮습니다.**





> 아래의 링크를 통해 *MySQL 공식문서*로 이동하실 수 있습니다.
>
> - 14.8.2 Regular Expressions : MySQL 공식문서 
>
> https://dev.mysql.com/doc/refman/8.0/en/regexp.html
>
> (한국어 버전)
>



## **🏁 강의 수강 (Study Schedule)**

| **주차** | **공부 범위**           | **완료 여부** |
| -------- | ----------------------- | ------------- |
| 0주차    | 서브쿼리 & CTE          | ✅             |
| 1주차    | 집합 연산자 & 그룹 함수 | ✅             |
| 2주차    | 윈도우 함수             | ✅             |
| 3주차    | Top N 쿼리              | ✅             |
| 4주차    | 계층형 질의 & 셀프 조인 | ✅             |
| 5주차    | PIVOT / UNPIVOT         | ✅             |
| 6주차    | 정규 표현식             | ✅             |



## 문제

- https://leetcode.com/problems/find-users-with-valid-e-mails/description/

> LeetCode 1517. Find Users With Valid E-mails
>
> 학습 포인트 : REGEXP를 활용한 이메일 유효성 검사 

- https://leetcode.com/problems/employees-with-missing-information/description/

> LeetCode 1965. Employees With Missing Information
>
> 학습 포인트 : REGEXP를 이용해 NULL 이 아닌 빈 문자열, 공백 등 이상값을 감지하기

**물론 REGEXP 없이 풀 수 있는 문제입니다. 하지만, 정규 표현식을 학습 한 만큼, 최대한 정규 표현식을 활용해서 문제를 풀어주세요**



---

## **1. 정규 표현식 REGEXP**

```
✅ 학습 목표 :
* `REGEXP`, `REGEXP_LIKE` 등으로 문자열 패턴 검색을 수행할 수 있다.
* `^`, `$`, `[abc]`, `.` 등 기본적인 정규표현식 패턴을 이해하고 WHERE절에 활용할 수 있다.
* 데이터 정제 및 분류 조건을 문자열 기반으로 처리할 수 있다.
```

✅ 정규 표현식
- 복잡한 검색 패턴을 지정하는 방법

| 이름                    | 설명                                   |
| --------------------- | ------------------------------------ |
| **NOT REGEXP**        | `REGEXP`의 부정(패턴과 일치하지 않는 경우)         |
| **REGEXP**            | 문자열이 정규 표현식 패턴과 일치하는지 여부             |
| **REGEXP\_INSTR()**   | 정규 표현식과 일치하는 부분 문자열의 시작 위치 반환        |
| **REGEXP\_LIKE()**    | 문자열이 정규 표현식과 일치하는지 여부                |
| **REGEXP\_REPLACE()** | 정규 표현식과 일치하는 부분 문자열을 다른 문자열로 치환      |
| **REGEXP\_SUBSTR()**  | 정규 표현식과 일치하는 부분 문자열을 반환              |
| **RLIKE**             | 문자열이 정규 표현식과 일치하는지 여부 (`REGEXP`와 동일) |


### Regular Expression Function and Operator Descriptions
1. `expr NOT REGEXP pat, expr NOT RLIKE pat`
- 의미
  - NOT (expr REGEXP pat)와 동일.
  - 즉, expr이 pat 패턴과 일치하지 않으면 1, 일치하면 0을 반환.

2. `expr REGEXP pat, expr RLIKE pat`
- 의미
  - expr 문자열이 패턴 pat(정규 표현식)과 일치하면 1, 일치하지 않으면 0을 반환.
  - expr 또는 pat이 NULL이면 결과는 NULL입니다.

```sql
SELECT 'Michael!' REGEXP '.*';
SELECT 'new*\n*line' REGEXP 'new\\*.\\*line';
- 문자열의 \n은 실제 개행이고, 정규식 .은 기본적으로 개행을 매칭하지 않음. 그래서 0 반환 
SELECT 'a' REGEXP '^[a-d]';
```

3. `REGEXP_INSTR()`
- 정의
  - 문자열 expr 안에서 정규식 pat 에 매칭되는 부분 문자열의 시작 위치를 반환합니다.
  - 문자 인덱스는 1부터 시작합니다.
- 구조
```sql
REGEXP_INSTR(expr, pat[, pos[, occurrence[, return_option[, match_type]]]])
```
- 옵션 인자 예시
```sql
SELECT REGEXP_INSTR('dog cat dog', 'dog');
```
  - pos 지정 안 함 → 기본값 1 → 문자열 처음부터 검색
  - 첫 번째 "dog"이 1번째 위치에서 시작하므로 결과는 1.

```sql
SELECT REGEXP_INSTR('dog cat dog', 'dog', 2);
```
  - pos = 2 → 2번째 문자부터 검색 시작
  - 2번째 문자는 "o"이지만, pos=2로 시작해도 첫 번째 "dog"는 건너뛰고 다음 "dog"이 매칭됩니다.
  - 두 번째 "dog"는 9번째 문자에서 시작하므로 결과는 9.

```sql
SELECT REGEXP_INSTR('aa aaa aaaa', 'a{2}');
```
  - 문자열: "aa aaa aaaa"
  - 패턴: a{2} → 연속된 a 2개를 찾기
  - 첫 "aa"가 1번째 문자에서 시작하므로 결과는 1. 

```sql
SELECT REGEXP_INSTR('aa aaa aaaa', 'a{4}');
```
  - 패턴: a{4} → 연속된 a 4개를 찾기
  - 앞쪽 "aa"나 "aaa"는 조건(4개 연속)에 안 맞음.
  - "aaaa"는 8번째 문자부터 시작하므로 결과는 8.


4. `REGEXP_SUBSTR()`
- 정의 
  - expr에서 pat에 처음으로 매칭된 부분 문자열 또는 지정한 번째 매치를 반환.

### Regular Expression Syntax

| 패턴                     | 의미                                 | 예시 결과                                     |      |                          |
| ---------------------- | ---------------------------------- | ----------------------------------------- | ---- | ------------------------ |
| `^`                    | 문자열 시작                             | `^fo` → `"fofo"` 매칭됨, `"afo"`는 불일치        |      |                          |
| `$`                    | 문자열 끝                              | `o$` → `"hello"` 매칭됨, `"helloo"` 불일치      |      |                          |
| `.`                    | 임의의 1문자(기본적으로 줄바꿈 제외, `m` 옵션 시 포함) | `^f.*$`                                   |      |                          |
| `*`                    | 앞 문자 0회 이상 반복                      | `Ba*n` → `"Bn"`, `"Ban"`, `"Baan"` 모두 OK  |      |                          |
| `+`                    | 앞 문자 1회 이상 반복                      | `Ba+n` → `"Ban"` OK, `"Bn"` 불일치           |      |                          |
| `?`                    | 앞 문자 0회 또는 1회                      | `Ba?n` → `"Ban"`, `"Bn"` OK, `"Baan"` 불일치 |      |                          |
| \`                     | \`                                 | OR(대안)                                    | \`pi | apa`→`"pi"`또는`"apa"\` 매칭 |
| `(abc)*`               | 그룹 0회 이상 반복                        | `^(pi)*$` → `"pi"`, `""`, `"pipi"` OK     |      |                          |
| `{m}`, `{m,}`, `{m,n}` | 반복 횟수 지정                           | `a{2,4}`                                  |      |                          |
| `[a-dX]`               | a\~d 또는 X                          | `[0-9]` 숫자 매칭                             |      |                          |
| `[^a-dX]`              | a\~d, X 제외                         |                                           |      |                          |
| `[=o=]`                | 동등 클래스(같은 Collation 값 문자)          |                                           |      |                          |
| `[[:alpha:]]`          | 문자 클래스 이름(alpha=알파벳 등)             | `[[:digit:]]` 숫자                          |      |                          |


---

## 확인문제

### **문제 1**

> **🧚권택이는 고객의 이메일을 필터링하는 작업을 하고 있습니다. 모든 고객 중 이메일 도메인이 @gmail.com 또는 @naver.com인 고객만 추출하고자 합니다. REGEXP를 활용하여 쿼리를 작성해보세요.**

```
SELECT *
FROM customers
WHERE email REGEXP '(@gmail\\.com|@naver\\.com)$';
```

1. > 위 쿼리가 어떤 의미인지 설명하고, LIKE로 동일한 결과를 내는 방법도 함께 제시해보세요.

2. > email이 빈 문자열이거나 NULL인 경우는 어떻게 처리해야 할지 고민해보세요.



> **🧚운영팀장인 지민이는 학회원 데이터에서 핸드폰 번호 형식을 점검하는 업무를 맡았습니다. 핸드폰 번호는 반드시 010으로 시작하고, 중간과 끝은 각각 4자리 숫자로 구성되어야 하며, 각 구간은 하이픈(-)으로 구분되어야 합니다. 예: 010-1234-5678 **
>
> **올바른 형식을 따르지 않는 번호를 가진 고객 목록을 찾아내기 위해 SQL의 REGEXP 기능을 사용하려고 합니다. 아래 조건에 맞는 고객 목록을 출력하는 쿼리를 작성해주세요.**

- 예시 테이블

| **student_id** | **name** | **phone_number** |
| -------------- | -------- | ---------------- |
| 1              | Anna     | 010-1234-5678    |
| 2              | Brian    | 011-1234-5678    |
| 3              | Cindy    | 01012345678      |
| 4              | David    | 010-123-5678     |
| 5              | Elsa     | 010-9999-8888    |

- 기대 출력 결과

| **student_id** | **name** | **phone_number** |
| -------------- | -------- | ---------------- |
| 2              | Brian    | 011-1234-5678    |
| 3              | Cindy    | 01012345678      |
| 4              | David    | 010-123-5678     |

> 문제 조건 
>
> - 형식이 **정확히** 010-XXXX-XXXX (X는 숫자, 총 4자리)인 경우만 통과
> - **정규 표현식을 사용하여 필터링**
> - 올바르지 않은 형식만 조회
> - 테이블 명은 Student로 해주세요.



~~~
여기에 쿼리를 작성해주세요.
~~~





<!-- 한 학기동안 SQL_ADVANCED 과제를 수행하느라 고생 많으셨습니다. 많이 부족했던 과제일 수 있지만, 과제를 하면서 SQL 지식이 성장했었다면 좋겠습니다. -->

### **🎉 수고하셨습니다.**
